// Generated by LispyScript v1.0.0
var part = require("lib/lib/functional/partialApplication.js");
var lib = require('lib');
var express = require("express");
var Path = require("path");
var child_process = require("child_process");
var prom = require("lib/lib/wrappers/promise.js");
var obj = require("lib/lib/wrappers/object.js");
var maybe = (require("lib/lib/functional/logical.js")).maybe;
var is = require("lib/lib/functional/predicates.js");
var functors = require("lib/lib/functional/functors.js");
var browserify = require("browserify");
var Dir = require("lib/lib/filesystem/Dir.js");
var openChatIo = require("./routers/chat.js");
var openFileIo = require("./routers/files.js");
var openUserIo = require("./routers/users.js").userIoHandler;

var Inode = lib.filesystem;
var print = console.log.bind(console);
var app = express();
var http = (require('http')).Server(app);
var io = require("socket.io")(http);
var curry = part["curry"];
var defer = part["defer"];
io.on("connection",function(socket) {
    socket.on("/chat",function() {
        console.log("hi");
    })
})

var handleExec = curry(function handleExec(s, f, e, stdout, stderr) {
    print(stderr.toString());
    return maybe.binary(function() {
        return f(e.stack);
    }, function() {
        return s(stdout.toString());
    }, e);
})
function exec(c) {
    return prom.create(function(success, fail) {
        return child_process.exec(c, handleExec(success, fail));
    });
}

function Monad(mv) {
    return function unit(mf) {
        return function bind() {
            return mf.call(bind, mv, ...arguments);
        }
    }
}

function DoMonad() {
    var fns = [...arguments];
    return function(bind) {
        return ((fns).map(bind)).reduce(function(scope, m) {
            m(scope);
            return scope;
        }, {
            io:io,
        });
    };
}

function defPrint() {
    return defer(print, [...arguments]);
}


function startHttpServer(dir, scope) {
    console.log("starting http server");
    app.use(express.static("./static"));
    return http.listen(8080, defPrint("http server listening on port 8080"));
}
function watchInode(dir, scope) {
    return dir.watch();
}

var browserIndexJS = /static\/.*index\.js/;
var browserJSCheck = /static\/.*\.js/;

function setAppCompile(dir, scope) {
    function changeCallback(path) {
        console.log(path, "changed");
        console.log("is index file?", browserIndexJS.test(path));
        console.log("is browser JS file?", browserJSCheck.test(path));

        if (!browserIndexJS.test(path) && browserJSCheck.test(path)) {

            console.log("index file to save", Path.join(Path.dirname(path), "..", "/index.js"));

            browserify()
                .transform("babelify", {
                    presets: ["es2015", "react"]
                })
                .add(path)
                .bundle()
                .on("error", function(err) {
                    console.log("There was an error when compileing", path);
                    print(err.stack);
                })
                .pipe(fs.createWriteStream(Path.join(Path.dirname(path), "..", "/index.js")));

        }
    }
    return dir.on("change", changeCallback);

}

function setWispCompile(dir, scope) {
    function compile(path) {
        var replacement = Path.basename(path,".wisp");
        replacement = Path.dirname(path) + "/"+ replacement + ".js";

        if ((Path.extname(path) === ".wisp")) {
            print("wisp file changed", path);
            print("wisp replacement file",replacement)
            exec("cat "+ path+ " | wisp > "+ replacement)
                .then(defer(console.log, ["successful compile"]))
                .catch(defer(console.log, ["compile fail"]));
        }
    }
    return dir.on("change", compile);
}
function setLispyCompile(dir, scope) {
    function compile(path) {
        var replacement = Path.basename(path,".ls");
        replacement = Path.dirname(path) + "/"+ replacement + ".js";

        if ((Path.extname(path) === ".ls")) {
            print("lispy file changed", path);
            print("lispy replacement file",replacement)
            exec("lispy " + path)
                .then(defer(console.log, ["successful compile"]))
                .catch(defer(console.log, ["compile fail"]));
        }
    }
    return dir.on("change", compile);
}
process.on("exit", function() {
    return (http).close();
});
Inode
    .get("./static")
    .then(Monad)
    .then(DoMonad(
        openChatIo,
        watchInode,
        setAppCompile,
        openFileIo,
        setLispyCompile,
        setWispCompile,
        openUserIo,
        startHttpServer
    ))
/*    .then(function() {
        return Inode
            .get("./")
            .then(Monad)
            .then(DoMonad(
                watchInode
                ));
    });*/
