"use strict";
var longjohn                      = require("longjohn");
longjohn.async_trace_limit = -1;
var Path                          = require("path");
var chokidar                      = require("chokidar");
var createInterface               = require("../interface.js").createInterface;
var cond                          = require("../functional/logical.js").conditional.binary;
var conditional                   = require("../functional/logical.js").conditional;
var functors                      = require("../functional/functors.js");
var hom                           = functors.hom;
var adhoc                         = hom.adhoc;
var curry                         = require("../functional/partialApplication.js").curry;
var is                            = require("../functional/predicates.js");
var EventInterface                = require("../events/EventInterface.js");
var evented                       = require("../events/eventedInterface.js");
var fs                            = require("fs");
var Promise                       = require("bluebird");
Promise.promisifyAll(fs);
function isFile(s) {
    return s.isFile();
};
function getFile(path) {
    var File = require("./File.js");
    return File.get(path)
};
function isDir(s) {
    return s.isDirectory();
};
function getDir(path) {
    var Dir = require("./Dir.js");
    return  Dir.get(path);
};
function notFound() {
    throw new TypeError
        ("disk entity type not recognized");
};
var checkType = function(x) {
    if(x.isFile()) {
        return getFile(this.path);
    } else if(x.isDirectory()) {
        return getDir(this.path);
    } else return notFound();
}
var Inode = evented({
    stat:function() {
        return fs.statAsync(this.path)
            .then((stats) => {
                this._stats = stats;
                this._statTime = Date.now();
                this.emit("stat",stats);
                return stats;
            });
    },
    /*on:function(m,f) {
      console.log("arguments",arguments);
        console.log("listening for",m);
        console.log("with handler",f);
        this._watcher.on(m,f);
        return this;
    },
    once:function(m,f) {
        this._watcher.once(m,f);
        return this;
    },*/
    getParent:function() {
        if (this._parent)
            return this._parent;
        this._parent = new Dir(Path.join("..", this.path));
        return this._parent;
    },
},
function Inode(path) {
    //EventInterface.call(this);
    this.path = path;
})
.methods({
    unwatch:function() {
        this._watcher.close();
        return this;
    },
    watch:function(config) {
        var inode = this;
        console.log("watching",this.path);
        this._watcher = chokidar
            .watch(this.path,config||{})
            .on("all",function (event){
                inode.emit(...arguments);
            }  );
        return this;
    },
})
.static({
    get:function(p) {
        var inode = new Inode(p);
        var stats =  inode.stat();
        console.log("getting",p)
        return stats
            .then((stats) => checkType.call(inode,stats));
    },
    watchFiles:function(ps,opts,handlers) {
        return Promise.all(ps.map(Inode.get))
            .then((inodes) => inodes
                  .watch(opts)
                  .handlers(handlers));
    },
    watchChange:function(ps,opts,handler) {
        return this.watch(ps,opts,{
            "change":handler
        });
    },
    setData:function(path,d) {
        return Inode.get(path)
            .then((file) => file.setContent(d))
    },
    getData:function(path,encoding) {
        return Inode.get(path)
            .then((file) => file.getContent(encoding))
    },
    watchOneChange:function(path,opts,handler) {
        return this.watch([path],opts,handler)
    },
});
/*
function contract(before,after,func) {
    return hom(curry(conditional.binary)(,() => func));
}
*/
module.exports = Inode;
