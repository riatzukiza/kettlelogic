var Inode = require("./Inode.js");
var createInterface = require("../interface.js").createInterface;
var logical = require("../functional/logical.js");
var maybe = logical.maybe.binary;
var mayhaps = logical.maybe;
var fs = require("fs");
var Promise = require("bluebird");
var part = require("../functional/partialApplication.js").bind;
Promise.promisifyAll(fs);

function maybeCache(d) {
    if (this.shouldCache) this._data = d
    return d;
};
var File = Inode
    .evented({
        _maybeData: function(f, g) {
            return maybe(f, g, this._data);
        },
        getContent: function(encoding) {
            return this._maybeData((d) => Promise.resolve(d),
                () => fs.readFileAsync(this.path, encoding)
                .then(maybeCache));
        },
        setContent: function(data) {
            return fs.writeFileAsync(this.path, data)
                .then(maybeCache.bind(this));
        },
        size: function() {
            return fs.statAsync(this.path)
                .then((s) => s.size);
        },
    }, function FileConstructor(path, pool, shouldCache) {

        console.log("Creating file", path)
        Inode.call(this, path);
        this.shouldCache = shouldCache || true;
        this._data = null;

    })
    .static({
        isNotLocked: function(f) {
            return function() {
                return maybe(this.stream,
                    (stream) => {
                        throw Error("file locked " + this.path);
                    }, f.bind(this));
            };
        },
        _files: new Map(),
        get: function(path) {
            console.log("getting file",path);
            if (this._files.has(path)) {
                console.log("file entity exists",path)
                return this._files.get(path);
            }
            else {
                console.log("getting file entity",path)
                var file = new File(path);
                this._files.set(path, file);
                return file;
            }
        },
        copy: function(p1, p2) {
            var f1 = File.get(p1);
            var read = f1.getReadStream();
            var f2 = File.get(p2);
            var write = f2.getWriteStream();

            read.pipe(write);
            return {
                origin: f1,
                destination: f2
            };
        }
    });
File = File.methods({
    getReadStream: function() {
        return this.stream = fs.createReadStream(this.path)
            .on("end", () => {
                delete this.stream;
            });
    },
    getWriteStream: function() {
        return this.stream = fs.createWriteStream(this.path)
            .on("end", () => {
                delete this.stream;
            });
    },
    pipe: function(dest) {
        var self = this.getReadStream();
        self.pipe(dest);
        this.emit("pipe", self, dest);
        return this;
    },
    copy: function(path) {
        return File.copy(this.path, path).destination;
    },
});

var file;
/*Inode.get("/home/aaron/devel/node_modules/lib/lib/filesystem/test.txt")
    .then((f) => {
        file = f;
        return file.watch()
            .on("change", (path, stats) =>
                file.getContent("utf8")
                .then(console.log
                    .bind(console, "is the content")))
            .getContent("utf8");
    })
    .then((data) => {
        console.log("this is the content", data);
        return file.setContent(data + " Oh, and bar is also foo.");
    })
    .then(() => file.copy("./otherTest.txt"))
    .then((otherFile) => otherFile.getContent())
    .then((s) => console.log("other file content", s))*/
module.exports = File;
