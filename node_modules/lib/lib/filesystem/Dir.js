"use strict";
var logical = require("../functional/logical.js");
var File = require("./File.js");
var Path = require("path");
var cond = logical.conditional.binary;

var is = require("../functional/predicates.js");
var maybe = logical.maybe.binary;
var functors = require("../functional/functors.js");
var getProp = functors.getProp;
var compose = functors.compose;

var fs = require("fs");
var Promise = require("bluebird");
var obj = require("../wrappers/array.js");
var part = require("../functional/partialApplication.js");
var curry = part.curry;
Promise.promisifyAll(fs);
var Inode = require("./Inode.js");

var iden = (c) => c;



var Dir = Inode.evented({
    getChildren_r() {
        return (maybeChildren(this));
    },
    getChildren() {
        return fs.readdir(this.path)
            .then(dir => Promise.all(Inode.get))
            .then((dir => this._dir = dir));
    },
    addChildren(a) {
        return Promise.all(a.map((n) => this.addChild(n)));
    },
    addChildren_r(o) {
        return Promise
            .all(obj.mask(o))
            .map(addChildren_r);
    },
    addDir(name) {
        return fs.mkdirAsync(Path.join(this.path, name));
    },
    getChild(name) {
        return Inode.get(Path.join(this.path, name), this._pool);
    },
    doesNotExist(name,f) {
        return this.getChild(name)
            .catch(err => err)
            .then((err) => {
                if(is.instanceof())
                throw new TypeError("cannot access file " + name +
                                    " inode with that name already exists")
            });
    },
    createFile(name,c) {
        return this.doesNotExist(name)
            .catch((err) => {
                return this.setFile(name,c);
            });
    },
    createDir(name) {
        return this.doesNotExist(name)
            .catch(() => this.setDir)
    },
    setFile(name, s) {
        return new File(Path.join(this.path, name), this._pool).setContents(s||"");
    },
    getParent() {
        return new Dir(Path.join("..", this.path));
    },
    getChildFile(name) {
        return new File(Path.join(this.path, name), this._pool);
    },
    getChildDir(name) {
        return new Dir(Path.join(this.path, name), this._pool);
    }
})
.methods({
})
.static({
    _directories:new Map(),
    get(path) {
        if(this._directories.has(path))
            return Promise.resolve(this._directories.get(path));

        var d = new Dir(path);

        this._directories.set(path,d);

        return d.stat()
            .then((stats) => {

                if(stats.isDirectory()) {
                    return d;
                } else {
                    this._directories.delete(path);
                    throw new TypeError("inode is not a directory");
                }

            });
    },
    getList(path) {
        return Dir.get(path)
            .then(dir => dir.getChildren());
    }
});
is.dir = part.curry(cond)(is.instanceof(Dir));

var maybeGetChildren =
        is.dir(( c ) => c.getChildren_r(),
               ( c ) => c);

var getChild = (dir) => (p) => dir.getChild(p);

var forAllDir = () => (children) => Promise.all (children.map(maybeGetChildren));

var getChildren = (dir) => (a) => Promise
        .all ( dir.children = a.map(getChild(dir)))
        .then(forAllDir(dir));

var getDirRec = (dir) => ( ) =>
        fs  . readdirAsync( dir.path )
        . then(getChildren(dir));

var maybeChildren = (dir) => maybe(
    iden,
    getDirRec(dir),
    dir.children);

var addChildren_r = (dir) => (x, k) => is.maybe.object(
    () => dir.addDir(k)
        .then(getChild(dir))
        .then((dir) => dir.addChildren_r(x)),
    () => dir.addFile(k, x), x).o
module.exports = Dir;
