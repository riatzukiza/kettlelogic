"use strict";
var mysql = require("mysql");
var evented = require("../events/eventedInterface.js");
var EventInterface = require("../events/EventInterface.js");
var EventEmitter = require("events").EventEmitter;
var prom = require("../wrappers/promise.js");
var obj = require("../wrappers/object.js");
var is = require("../functional/predicates.js");
var maybe = require("../functional/logical.js").maybe.binary;
const CONNECTING = 0;
const CONNECTED = 1;
const DISCONNECTED = 2;
/**
 * given an object, create an sql parameters list where the values of the object are escaped.
 * */
function sqlList(o) {
    return Object
        .keys(o)
        .map((k) => `${k} = ${mysql.escape(o[k])}`) .join(", ");
}
/**
 * given an array, return a string with each element of the array delimited by spaces.
 * */
function joinWithSpaces(a) {
    return a.join(" ");
}
/**
 * return an empty string
 * */
function otherwiseReturnEmptyString() {
    return "";
}
/**
 * given a value, if that value is an array, return a space delimited string of the values of that array
 * other wise return an empty string.
 * */
function maybeJoinWithSpaces(v) {
    return is.maybe.array(
        v,
        joinWithSpaces,
        otherwiseReturnEmptyString);
}
/**
 * */
function maybeConstraints(v, i) {
    return `${i} ${v[0]} ${maybeJoinWithSpaces(v[1])}`;
}

function handleNextCol(prev, next, k, o) {
    prev.push(next);
    return prev;
}

function generateTableSchema(cols) {
    return obj.mask(cols)
        .map_reduce(maybeConstraints, (handleNextCol), []).join(",");
}
function buildConstraintsFromArray(c) {
    return ("," + c.join(","));
}
function buildConstraintsFromString(c) {
    return is.maybe.string (c, ((c) => c), (() => ""))
}
function generateConstraints(constraints) {
    console.log("constriants?",constraints);
    return is.maybe.array(
        constraints,
        buildConstraintsFromArray,
        buildConstraintsFromString);

}
function CREATE_TABLE(name, cols,constraints) {
    return (
`CREATE TABLE IF NOT EXISTS
    ${name} (${generateTableSchema(cols)}
    ${maybe(generateConstraints,()=>"",constraints)});`);
}

function createTable(name, cols) {
    return query(CREATE_TABLE(name, cols));
}
var Database = EventInterface
        .evented({
            /**
            * connect to the sql database using the credentials given during interface instantiation.
            * */
            connect() {
                console.log("connecting to the database");
                console.log("credentials",this.database,this.host,this.user,this.password)
                //if (this.status !== CONNECTED) {}
                this.session = mysql.createConnection({
                    connectionLimit: 10,
                    database: this.database,
                    host: this.host,
                    user: this.user,
                    password: this.password
                });
                return new Promise((resolve, reject) => {
                    this.session.connect((err) => {
                        console.log("connected to session?")
                        if (err) {
                            console.log("error connecting",err)
                            if (this._attempts < this._maxTries) {
                                console.log("error on connection", err);
                                console.log("attempting to reconnect in 2 seconds");
                                return setTimeout(() => resolve(this.connect()), 2000);
                            } else {
                                return reject(this.timeout(err));
                            }
                        }
                        console.log("connected to database");
                        resolve(this.connected());
                    });
                });
            },
            /**
            * handle successful connection to database.
            * */
            connected() {
                this.status = CONNECTED;
                //this.emit("connected");
            },
            /**
            * handle timeout from database.
            * */
            timeout(err) {
                this.status = DISCONNECTED;
                var customErr = new Error("failed to connected too many times");
                customErr.originalError = err;
                return customErr;
            },
            /**
            * query the database with a given string.
            * */
            query(s) {
                if (this.status === CONNECTED) {
                    console.log("query:",s);
                    return prom.create((resolve, reject) =>
                        this.session.query(s, function(err, res) {
                            let a = [...arguments].slice(1);
                            if (err) {
                                console.log("QUERY ERROR",err);
                                return reject(err);
                            }
                            return resolve({
                                rows: a[0],
                                fields: a[1]
                            });
                        }));
                } else {
                    return prom.create((resolve, reject) =>{
                        this
                        .once("connected", () =>
                            resolve(this.query(s)))
                        this.once("error", reject);
                    });
                }
            },
            /**
            * select all rows that match a set of constraints.
            * */
            selectWhere(t, c) {
                return this.query(`SELECT * FROM ${t}
                WHERE ${sqlList(c)};`);
            },
            selectAll(t)  {
                return this.query(`SELECT * FROM ${t};`);
            },
            /**
            * update a set of rows that match a set of given constraints.
            * */
            update(t, v, c) {
                console.log("updating",...arguments);
                return this.query(`UPDATE ${t} SET ${sqlList(v)}
                WHERE ${sqlList(c)};`);
            },
            /**
            * remove a table by name.
            * */
            dropTable(t) {
                return this.query(`DROP TABLE ${t};`);
            },
            /**
            * insert a row to a table with the values given.
            * */
            insert(t, k, data) {
                return this.query(
                    `INSERT INTO ${t}  (${k.join(", ")})
                    VALUES (${data.map((v,i) => mysql.escape(v))});`);
            },
            /**
            * increment the value of a field on a table.
            * */
            increment(t, field, c) {
                return this.query(
                    `UPDATE ${t} SET ${field} = ${field} + 1
                WHERE ${sqlList(c)};`);
            },
            /**
            * return a description of a table.
            * */
            describeTable(t) {
                return this.query(`DESCRIBE ${t};`);
            },
            /**
            * insert a row into a table populated by default values.
            * */
            insertDefault(table, keys) {
                return this.query(`INSERT INTO ${table}
                    VALUES (${keys.map(() => "DEFAULT")});`);
            },
            /**
            * delete a set of fields on a table that match a set of constraints.
            * */
            delete(t, c) {
                var q = (`DELETE FROM ${t}
                    WHERE ${sqlList(c)};`);
                console.log("delete query string",q);
                return this.query(q);
            }
        })
        .methods({
            /**
             * create a new sql table given a set of columns and constraints
             * */
            createTable(name, cols, constraints) {
                var table = new Table(name, cols, this);
                //this.tables[name] = table;
                this.query(CREATE_TABLE(name, cols,constraints))
                    .then(() => table.emit("ready"));
                return table;
            },
        })
        .Constructor(function Database(
            name,
            host,
            username,
            password,
            maxTries
        ) {
            EventInterface.call(this);
            this.database = name;
            this.host = host;
            this.user = username;
            this.password = password;
            this._attempts = 0;
            this._maxTries = maxTries || 10;
            this.tables = {};
            this.status = CONNECTING;
            console.log("THIS",this)
            this.connect()

            //if an error should occur on the database we need to determine if it is a disconnect
            //or another error. We can gracefully handle a disconnect by attempting to reconnect, all
            //other errors must be passed upwards.
            this.session.once('error', (e) => {
                if (e === null) return;
                else if (e.code === "PROTOCOL_CONNECTION_LOST") {
                    this.status = CONNECTING;
                    console.log("reconnecting to sql server");
                    this.connect();
                } else {
                    console.log("sql error", e);
                    this.emit('error', e);
                }
            });
        });
module.exports = Database;
var Table = require("./table/table.js");
