"use strict";
var F = require( "./functional.js" );
var is = F.is;
var cond = F.cond;
var curry = F.curry;
var obj = require( "./object.js" );

function maybeFunc( x, f )
{
	return cond( is.function, f, ( x ) => x, x );
}
////////////////////////////////////////////////////////////////////////////////
function postMorph( f, pre, k, args )
{
	return f.call( this, ...pre.call( this, k, ...args ) );
}

function preMorph( f, post, k, args )
{
	return post.call( this, f.call( this, k, ...args ) );
}

function hom( f, pre, post, k, args )
{
	return post.call( this, f.call( this, ...pre.call( this, k, ...args ) ), k, args );
}

function modMorph( f, binder, k, args )
{
	var self = this;
	return binder.call( this, k, args, function()
	{
		f.call( self, ...arguments );
	});
}
////////////////////////////////////////////////////////////////////////////////
function insertBefore( f, pre, k )
{
	return function()
	{
		return preMorph( f, pre, k, arguments );
	};
}

function insertAfter( f, post, k )
{
	return function()
	{
		return postMorph( f, post, k, arguments );
	};
}

function insertHom( f, pre, post, k )
{
	return function()
	{
		return hom( f, pre, post, k, arguments );
	};
}

function insertMod( f, binder, k )
{
	return function()
	{
		return modMorph( f, binder, k, arguments );
	};
}
////////////////////////////////////////////////////////////////////////////////
function preMap( o, pre )
{
	return obj.mask( o )
		.map( ( f ) => maybeFunc( f, insertBefore( f, pre ) ) );
}

function postMap( o, post )
{
	return obj.mask( o )
		.map( ( f ) => maybeFunc( f, insertAfter( f, post ) ) );
}

function homMap( o, pre, post )
{
	return obj.mask( o )
		.map( ( f, k ) => maybeFunc( f, insertHom( f, pre, post, k ) ) );
}

function mapMod( o, binder )
{
	return obj.mask( o )
		.map( ( f ) => maybeFunc( mod( f, binder ), f ) );
}
////////////////////////////////////////////////////////////////////////////////
function preProduct( o, fo )
{
	return obj.mask( o )
		.map( ( x, k ) => maybeFunc( insertBefore( x, fo[ k ] ), x ) );
}

function postProduct( o, fo )
{
	return obj.mask( o )
		.map( ( x, k ) => maybeFunc( insertAfter( x, fo[ k ] ), x ) );
}

function homProduct( o, before, after )
{
	return obj.mask( o )
		.map( ( x, k ) => maybeFunc( insertHom( x, before[ k ], after[ k ] ) ), x );
}

function modProduct( o, mod )
{
	return obj.mask( o )
		.map( ( x, k ) => maybeFunc( x, insertMod( x, mod[ k ] ) ) );
}
////////////////////////////////////////////////////////////////////////////////
function mutatePrototype( cl, f )
{
	cl.prototype = f( cl.prototype );
	return cl;
}
////////////////////////////////////////////////////////////////////////////////
function homClassProduct( cl, before, after )
{
	return mutatePrototype( cl, ( p ) => homProduct( p, before, after ) );
}

function modClassProduct( cl, mod )
{
	return mutatePrototype( cl, ( p ) => modProduct( p, mod ) );
}

function preClassProduct( cl, pre )
{
	return mutatePrototype( cl, ( p ) => preProduct( p, pre ) );
}

function postClassProduct( cl, post )
{
	return mutatePrototype( cl, ( p ) => postProduct( p, post ) );
}
////////////////////////////////////////////////////////////////////////////////
function homClassMap( cl, before, after )
{
	return mutatePrototype( cl, ( p ) => homMap( p, before, after ) );
}

function modClassMap( cl, mod )
{
	return mutatePrototype( cl, ( p ) => modMap( p, mod ) );
}

function preClassMap( cl, pre )
{
	return mutatePrototype( cl, ( p ) => preMap( p, pre ) );
}

function postClassMap( cl, post )
{
	return mutatePrototype( cl, ( p ) => postMap( p, post ) );
}
////////////////////////////////////////////////////////////////////////////////
function aspectExistingClass( cl, pre, post, mod )
{

}

function createAspectedClass( f, proto, superClass, aspect )
{
	return aspectExistingClass( obj.createClass( f, proto, superClass ), aspect );
}
module.exports = {
	insert:
	{
		mod: insertMod,
		before: insertBefore,
		insertAfter: insertAfter,
		hom: insertHom,
	},
	map:
	{
		modMap,
		before: preMap,
			after: postMap,
			hom: homMap
	},
	product:
	{
		modProduct,
		before: preProduct,
			after: postProduct,
			hom: homProduct,
	}
};
