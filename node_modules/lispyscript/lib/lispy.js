// Generated by LispyScript v1.0.0
require("./require");
var fs = require("fs"),
    path = require("path"),
    ls = require("./ls"),
    repl = require("./repl"),
    watch = require("watch"),
    isValidFlag = /-h\b|-r\b|-v\b|-b\b|-s\b/,
    error = function(err) {
        console.error(err.message);
        return process.exit(1);
    };
var opt = ((((require('node-getopt')).create([['h', 'help', 'display this help'],
    ['v', 'version', 'show version'],
    ['r', 'run', 'run .ls files directly'],
    ['w', 'watch', 'watch and compile changed files beneath current directory'],
    ['b', 'browser-bundle', 'create browser-bundle.js in the same directory'],
    ['m', 'map', 'generate source map files'],
    ['i', 'include-dir=ARG+', 'add directory to include search path']])).setHelp(("lispy [OPTION] [<infile>] [<outfile>]\n\n" + "<outfile> will default to <infile> with '.js' extension\n\n" + "Also compile stdin to stdout\n" + "eg. $ echo '(console.log \"hello\")' | lispy\n\n" + "[[OPTIONS]]\n\n"))).bindHelp()).parseSystem();
(function(___monad) {
    var mBind = ___monad.mBind,
        mResult = ___monad.mResult,
        mZero = ___monad.mZero,
        mPlus = ___monad.mPlus;
    var ____mResult = function(___arg) {
        return (((typeof(___arg) === "undefined") && (!(typeof(mZero) === "undefined"))) ?
            mZero :
            mResult(___arg));
    };
    return mBind((((opt.argv.length === 0) && ((Object.keys(opt.options)).length === 0)) ?
        (function() {
            var input = process.stdin;
            var output = process.stdout;
            input.resume();
            input.setEncoding("utf8");
            var source = "";
            input.on("data",function(chunck) {
                source = (source + chunck.toString());
            });
            input.on("end",function() {
                return (function() {
                try {
                    return output.write(ls._compile(source,process.cwd));

                } catch (e) {
                return (error)(e);
                }
                })();
            });
            input.on("error",error);
            output.on("error",error);
            setTimeout(function() {
                return ((input.bytesRead === 0) ?
                    (function() {
                        input.removeAllListeners("data");
                        return repl.runrepl();
                    })() :
                    undefined);
            },20);
            return null;
        })() :
        undefined),function(noargs) {
        return mBind(((true === opt.options['version']) ?
            (function() {
                console.log(("Version " + ls.version));
                return null;
            })() :
            ((true === opt.options['browser-bundle']) ?
                (function() {
                    var bundle = require.resolve("lispyscript/lib/browser-bundle.js");
                    (fs.createReadStream(bundle)).pipe(fs.createWriteStream("browser-bundle.js"));
                    return null;
                })() :
                ((true === opt.options['run']) ?
                    (function() {
                        var infile = (opt.argv[0] ?
                            (((opt.argv[0].indexOf('.ls') === -1) && (opt.argv[0].indexOf('.js') === -1)) ?
                                error(new Error("Error: Input file must have extension '.ls' or '.js'")) :
                                opt.argv[0]) :
                            error(new Error("Error: No Input file given")));
                        require(infile);
                        return null;
                    })() :
                    ((true === opt.options['watch']) ?
                        (function() {
                            var cwd = process.cwd();
                            console.log('Watching',cwd,'for .ls file changes...');
                            watch.watchTree(cwd,{
                                filter: function(f,stat) {
                                    return (stat.isDirectory() || (f.indexOf('.ls') !== -1));
                                },
                                ignoreDotFiles: true,
                                ignoreDirectoryPattern: /node_modules/
                            },function(f,curr,prev) {
                                return ((curr && (curr.nlink !== 0)) ?
                                    (require("child_process")).spawn("lispy",[f.substring(cwd.length+1)],{stdio: "inherit"}) :
                                    (((Object.prototype.toString.call(f) === "[object Object]") && (prev === null) && (curr === null)) ?
                                        (function(o,f,s) {
                                            var _k = Object.keys(o);
                                            return (_k).forEach(function(elem) {
                                                return f.call(s,o[elem],elem,o);
                                            });
                                        })(f,function(stat,initialf) {
                                            return ((!(initialf === cwd)) ?
                                                (function() {
                                                    return (function() {
                                                        return (require("child_process")).spawn("lispy",[initialf.substring(cwd.length+1)],{stdio: "inherit"});
                                                    })();
                                                })() :
                                                undefined);
                                        }) :
                                        undefined));
                            });
                            return null;
                        })() :
                        (true ?
                            true :
                            undefined))))),function(compile) {
            return mBind((opt.argv[0] ?
                opt.argv[0] :
                error(new Error("Error: No Input file given"))),function(infile) {
                return mBind((function() {
                    var outfile = opt.argv[1];
                    ((!outfile) ?
                        (function() {
                            return (function() {
                                outfile = infile.replace(/\.ls$/,".js");
                                return ((outfile === infile) ?
                                    error(new Error("Error: Input file must have extension '.ls'")) :
                                    undefined);
                            })();
                        })() :
                        undefined);
                    return outfile;
                })(),function(outfile) {
                    return (function() {
                        return ____mResult((function() {
                        try {
                            console.log('LispyScript v1.0.0:  compiling',infile,'to',outfile);
                            return fs.writeFileSync(outfile,ls._compile(fs.readFileSync(infile,"utf8"),infile,(true === opt.options['map']),opt.options['include-dir']),"utf8");

                        } catch (e) {
                        return (function(err) {
                            error(err);
                            return null;
                        })(e);
                        }
                        })());
                    })();
                });
            });
        });
    });
})({
    mBind: function(mv,mf) {
        return ((mv === null) ?
            null :
            mf(mv));
    },
    mResult: function(v) {
        return v;
    },
    mZero: null
});
